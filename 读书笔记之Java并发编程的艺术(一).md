title: 读书笔记之Java并发编程的艺术(一)  
tags: [Java,并发]  
date: 2017-10-12  

---  
**如何减少上下文切换？**

减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程  
- 无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以使用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据  
- CAS:Java的Atomic包使用CAS算法来更新数据，并不需要加锁  
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换  

**避免死锁的方法：**

- 避免一个线程同时获取多个锁  
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源  
- 尝试使用定时锁，使用lock.tryLock(tomeout)来替代使用内部锁机制  
- 对于数据库锁，加锁和解锁必须在同一个连接里，否则会出现解锁失败的情况  

### Java并发机制的底层实现原理 ###  

volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”，如果volatile使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。  

使用volatile修饰的变量进行编译时会出现一个Lock前缀指令，Lock前缀指令做了两件事：
1. 将当前处理器缓存行的数据写回到系统内存  
2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效  

**synchronized的实现原理**  

JVM基于进入和退出Minitor对象来实现方法同步和代码块同步。代码块同步是利用monitorenter和monitorexit指令实现的  

在Java SE1.6中，锁一共有4中状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。  

**原子操作的实现原理**  

原子操作为不可能中断的一个或一系列操作  
处理器使用基于缓存加锁或总线加锁的 方式来实现多处理器之间的原子操作  
数据不能缓存在处理器内部或者处理器不存在缓存功能  

在java中可以通过锁和循环CAS的方式来实现原子操作  

Java并发中线程之间的通信是通过共享内存进行通信的，隐式通信  

重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段  
