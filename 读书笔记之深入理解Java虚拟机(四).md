title: 读书笔记之深入理解Java虚拟机：JVM高级特性与最佳实践（周志明著）（四）  
tags: [JVM,java]  
date: 2017-10-11

---  

### 调优分析与虚拟机类加载机制 ###  

#### 调优分析 ####  

Direct Memory 不能像新生代、老年代那样，发现空间不足了就通知收集器进行回收，它只能等待老年代满了后Full GC,然后顺便地帮它清理掉内存的废弃对象。  

**Eclipse的一些配置：**

我们可以把-Xms和-XX:PermSize参数值设置与-Xmx和-XX:MaxPermSize参数值一样，这样就强制虚拟机在启动的时候就把老年代和永久代的容量固定下来，避免运行时自动扩展  

新生代GC频繁发生，我们可以通过-Xmn参数调整新生代的大小

需要的情况下我们可使用-Xverify:none参数禁止字节码验证过程  

还可以指定回收算法，新生代指定ParNew收集器，老年代指定CMS收集器  

#### 虚拟机类加载机制 ####  

在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。  

类从被加载到虚拟机内存中开始，到卸载出内存位置，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用和卸载7个阶段。  

验证阶段大致会包含以下四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证  

准备阶段会为static变量分配内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中  

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程  

#### 双亲委派模型 ####  

从Java虚拟机的角度来讲，只存在两种不同的类加载器：一是启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分。二是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader  

**启动类加载器（Bootstrap ClassLoader）：** 这个类加载器负责将存放在JAVA_HOME\lib 目录中的或者被-Xbootclasspath参数所指定的路径中的，并且虚拟机识别的类库加载到虚拟机内存中。  

**扩展类加载器（Extension ClassLoader）：** 负责加载JAVA_HOME\lib\ext目录中的，或者被java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。  

**应用程序类加载器：** 负责加载用户类路径（ClassPath）上所指定的类库  

**双亲委派模型的工作过程：** 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是委派给父类加载器去完成，所以说所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个请求时，子加载器才会自己尝试去加载。  

总结：  
ClassLoader用来加载class文件的。  
系统内置的ClassLoader通过双亲委托来加载指定路径下的class和资源。  
可以自定义ClassLoader一般覆盖findClass()方法。  
ContextClassLoader与线程相关，可以获取和设置，可以绕过双亲委托的机制。  
