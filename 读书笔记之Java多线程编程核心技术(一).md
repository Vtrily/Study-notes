title: 读书笔记之Java多线程编程核心技术（高洪岩著）（一）  
tags: [java,多线程]  
date:2017-10-09  

---  

Java虚拟机中的多线程是通过线程的轮流切换并分配处理器执行时间的方式来实现的。在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。  

##### 多线程的实现 #####
继承Thread类和实现Runnable接口  

##### 终止正在运行的线程： #####
1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止  
2.使用stop方法强行终止线程，但是不推荐使用这个方法  
3.使用interrupt方法中断线程，使用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。  

##### 判断线程是否是停止状态 #####
Thread.java类里提供了两种方法  
this.interrupted()：测试当前线程是否已经中断，清除状态  
this.isInterrupted():测试线程是否已经中断，不清楚状态  

能使用for语句来判断一下线程是否是停止状态，如果是停止状态则可以抛出异常阻止循环之后的代码继续执行  

interrrupt()与return结合使用也能实现停止线程的效果  

在Java多线程中，可以使用suspend()方法暂停线程，使用resume()方法恢复线程的执行，在使用suspend与resume方法时，如果使用不当，极易造成公共的同步对象的独占，使得其他线程无法访问公共同步对象，也容易出现因为线程的暂停而导致数据不同步的情况  

yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。  

在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务  

设置线程的优先级使用setPriority()方法  

线程优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的  

CPU ** 尽量 ** 将执行资源让给优先级比较高的线程  

#### 守护线程 ####  

在Java线程中有两种线程，一种是用户线程，另一种就是守护线程  

守护线程具有陪伴的含义，是为了守护非守护线程而存在的，最典型的守护线程就是垃圾回收线程  
守护线程最典型的应用就是GC(垃圾回收器)  

#### 线程安全与非线程安全 ####  

“非线程安全”其实会在躲在线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是“脏读”，也就是取到的数据其实是被更改过的。而“线程安全”就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。  

“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”，方法中的变量永远都是线程安全的  

如果多个线程共同访问一个对象中的实例变量，则有可能出现“非线程安全问题”  

只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要  

synchronized锁重入  
关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。这也证明在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。  


当一个线程执行的代码出现异常时，其所持有的锁会自动释放  

同步不具有继承性  

同步方法和同步代码块  
同步方法存在弊端，耗时过长会影响其他线程使用该方法  

不在synchronized块中就是异步执行，在synchronized块中就是同步执行  

和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的  

当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象中的非synchronized(this)同步代码块  

锁非this对象的优点：  
如果一个类中有很多个synchronized方法，这时虽然能是西安同步，但会受到阻塞，所以影响效率；但如果使用同步代码块锁非this对象，则synchronized(非this)代码块中的程序与同步方法是异步的，不与其他锁this同步方法挣抢this锁，则可以大大提高运行效率  

synchronized关键字加到static静态方法上是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁  

使用JDK自带工具检测是否存在死锁jstack -l 进程号，使用jps命令查看进程号  

synchronized和volatile的区别  
1.关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是很大的  
2.多线程访问volatile不会发生阻塞，而synchronized会出现阻塞  
3.volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和共有内存中的数据做同步。  
4.关键字volatile解决的是变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性  
